"""
Generate PDF from Markdown Research Report (Simple Version)

Uses fpdf2 - a pure Python PDF library with no system dependencies.
Produces professional-looking PDFs from markdown research reports.

Install: pip install fpdf2 markdown
"""
import os
import sys
import re
import argparse
from datetime import datetime

try:
    from fpdf import FPDF
    FPDF_AVAILABLE = True
except ImportError:
    FPDF_AVAILABLE = False

try:
    import markdown
    from markdown.extensions.tables import TableExtension
    MARKDOWN_AVAILABLE = True
except ImportError:
    MARKDOWN_AVAILABLE = False


class ResearchReportPDF(FPDF):
    """Custom PDF class for research reports with professional styling"""
    
    def __init__(self):
        super().__init__()
        self.set_auto_page_break(auto=True, margin=25)
        
        # Add DejaVu font for Unicode support
        # fpdf2 includes these fonts built-in
        try:
            self.add_font('DejaVu', '', 'DejaVuSans.ttf')
            self.add_font('DejaVu', 'B', 'DejaVuSans-Bold.ttf')
            self.add_font('DejaVu', 'I', 'DejaVuSans-Oblique.ttf')
            self.add_font('DejaVu', 'BI', 'DejaVuSans-BoldOblique.ttf')
            self.unicode_font = 'DejaVu'
        except Exception:
            # Fallback to Helvetica if DejaVu is not available
            self.unicode_font = 'Helvetica'
        
        self.title_text = ""
        self.current_chapter = ""
        
    def header(self):
        """Page header"""
        if self.page_no() > 1:
            font = getattr(self, 'unicode_font', 'Helvetica')
            self.set_font(font, 'I', 9)
            self.set_text_color(128, 128, 128)
            # Header text
            header_text = self.current_chapter[:60] if self.current_chapter else ""
            self.cell(0, 10, self._process_text(header_text) if hasattr(self, '_process_text') else header_text, align='C')
            self.ln(5)
            # Line
            self.set_draw_color(200, 200, 200)
            self.line(20, 15, self.w - 20, 15)
            self.ln(10)
    
    def footer(self):
        """Page footer"""
        self.set_y(-20)
        font = getattr(self, 'unicode_font', 'Helvetica')
        self.set_font(font, 'I', 9)
        self.set_text_color(128, 128, 128)
        # Page number
        self.cell(0, 10, f'Page {self.page_no()}', align='C')
        
    def add_title_page(self, title: str, subtitle: str = "A Comprehensive Research Survey"):
        """Create a professional title page"""
        self.add_page()
        
        # Title area
        self.ln(60)
        
        # Main title
        self.set_font(self.unicode_font, 'B', 24)
        self.set_text_color(26, 54, 93)  # Dark blue
        
        # Word wrap for long titles
        title = self._process_text(title)
        title_lines = self._wrap_text(title, 160)
        for line in title_lines:
            self.cell(0, 14, line, align='C')
            self.ln(14)
        
        self.ln(10)
        
        # Subtitle
        self.set_font(self.unicode_font, 'I', 14)
        self.set_text_color(74, 85, 104)
        self.cell(0, 10, subtitle, align='C')
        
        self.ln(40)
        
        # Decorative line
        self.set_draw_color(49, 130, 206)
        self.set_line_width(0.5)
        self.line(60, self.get_y(), self.w - 60, self.get_y())
        
        self.ln(40)
        
        # Generation info
        self.set_font(self.unicode_font, '', 11)
        self.set_text_color(113, 128, 150)
        self.cell(0, 8, "Generated by Deep Research Swarm", align='C')
        self.ln(8)
        self.cell(0, 8, datetime.now().strftime('%B %d, %Y'), align='C')
        
        self.title_text = title
    
    def add_chapter_title(self, title: str, level: int = 2):
        """Add a chapter/section title"""
        self.current_chapter = title
        title = self._process_text(title)
        
        if level == 2:
            # Major section
            if self.get_y() > 200:  # Page break if near bottom
                self.add_page()
            self.ln(10)
            self.set_font(self.unicode_font, 'B', 16)
            self.set_text_color(44, 82, 130)
            self.multi_cell(0, 10, title)
            # Underline
            self.set_draw_color(190, 227, 248)
            self.set_line_width(0.8)
            y = self.get_y() + 2
            self.line(20, y, self.w - 20, y)
            self.ln(8)
        elif level == 3:
            # Subsection
            self.ln(6)
            self.set_font(self.unicode_font, 'B', 13)
            self.set_text_color(45, 55, 72)
            self.multi_cell(0, 8, title)
            self.ln(4)
        elif level == 4:
            # Sub-subsection
            self.ln(4)
            self.set_font(self.unicode_font, 'B', 11)
            self.set_text_color(74, 85, 104)
            self.multi_cell(0, 7, title)
            self.ln(3)
    
    def add_paragraph(self, text: str, is_abstract: bool = False):
        """Add a paragraph of text"""
        if is_abstract:
            # Abstract styling - boxed
            self.set_fill_color(235, 248, 255)
            self.set_font(self.unicode_font, '', 10)
            self.set_text_color(26, 32, 44)
            
            # Draw background box
            start_y = self.get_y()
            self.rect(20, start_y, self.w - 40, 10, 'F')
            
        self.set_font(self.unicode_font, '', 11)
        self.set_text_color(26, 26, 26)
        
        # Process text for basic formatting
        text = self._process_text(text)
        self.multi_cell(0, 6, text)
        self.ln(4)
    
    def add_bullet_point(self, text: str, indent: int = 0):
        """Add a bullet point"""
        self.set_font(self.unicode_font, '', 10)
        self.set_text_color(26, 26, 26)
        
        x_offset = 25 + (indent * 10)
        self.set_x(x_offset)
        
        # Bullet - use simple dash for compatibility
        self.cell(5, 6, '-')
        
        # Text
        text = self._process_text(text)
        self.multi_cell(0, 6, text)
        self.ln(2)
    
    def add_numbered_item(self, number: int, text: str):
        """Add a numbered list item"""
        self.set_font(self.unicode_font, 'B', 10)
        self.set_text_color(44, 82, 130)
        self.set_x(25)
        self.cell(10, 6, f"{number}.")
        
        self.set_font(self.unicode_font, '', 10)
        self.set_text_color(26, 26, 26)
        text = self._process_text(text)
        self.multi_cell(0, 6, text)
        self.ln(2)
    
    def add_table(self, headers: list, rows: list):
        """Add a simple table"""
        self.ln(4)
        
        # Calculate column widths
        col_count = len(headers)
        col_width = (self.w - 40) / col_count
        
        # Header row
        self.set_font(self.unicode_font, 'B', 10)
        self.set_fill_color(44, 82, 130)
        self.set_text_color(255, 255, 255)
        
        for header in headers:
            self.cell(col_width, 8, self._process_text(str(header)[:20]), border=1, align='C', fill=True)
        self.ln()
        
        # Data rows
        self.set_font(self.unicode_font, '', 10)
        self.set_text_color(26, 26, 26)
        fill = False
        
        for row in rows:
            if fill:
                self.set_fill_color(247, 250, 252)
            else:
                self.set_fill_color(255, 255, 255)
            
            for cell in row:
                self.cell(col_width, 7, self._process_text(str(cell)[:30]), border=1, align='L', fill=True)
            self.ln()
            fill = not fill
        
        self.ln(4)
    
    def add_citation(self, text: str):
        """Add a citation reference"""
        self.set_font(self.unicode_font, 'I', 9)
        self.set_text_color(113, 128, 150)
        text = self._process_text(text)
        self.multi_cell(0, 5, text)
        self.ln(2)
    
    def add_horizontal_rule(self):
        """Add a horizontal divider"""
        self.ln(5)
        self.set_draw_color(226, 232, 240)
        self.line(40, self.get_y(), self.w - 40, self.get_y())
        self.ln(5)
    
    def _wrap_text(self, text: str, max_width: int) -> list:
        """Wrap text to fit within max_width"""
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = f"{current_line} {word}".strip()
            # Approximate width check (rough estimate)
            if len(test_line) * 3 > max_width:
                if current_line:
                    lines.append(current_line)
                current_line = word
            else:
                current_line = test_line
        
        if current_line:
            lines.append(current_line)
        
        return lines
    
    def _process_text(self, text: str) -> str:
        """Process markdown-like text formatting"""
        # Remove markdown bold/italic markers (fpdf2 doesn't support inline formatting easily)
        text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)  # Bold
        text = re.sub(r'\*([^*]+)\*', r'\1', text)  # Italic
        text = re.sub(r'`([^`]+)`', r'\1', text)  # Code
        
        # Clean up citations
        text = re.sub(r'\[([^\]]+)\]', r'[\1]', text)
        
        # Replace special Unicode characters with ASCII equivalents
        replacements = {
            '‚Äî': '-',       # em dash
            '‚Äì': '-',       # en dash
            '"': '"',       # left double quote
            '"': '"',       # right double quote
            ''': "'",       # left single quote
            ''': "'",       # right single quote
            '‚Ä¶': '...',     # ellipsis
            '‚úÖ': '[OK]',   # check mark
            '‚ùå': '[X]',    # x mark
            '‚úì': '[v]',     # check
            '‚úó': '[x]',     # x
            '‚Ä¢': '-',       # bullet
            '‚óè': '*',       # filled circle
            '‚óã': 'o',       # empty circle
            '‚ñ∫': '>',       # right arrow
            '‚óÑ': '<',       # left arrow
            '‚Üí': '->',      # arrow
            '‚Üê': '<-',      # arrow
            '‚Üë': '^',       # up arrow
            '‚Üì': 'v',       # down arrow
            '¬©': '(c)',     # copyright
            '¬Æ': '(R)',     # registered
            '‚Ñ¢': '(TM)',    # trademark
            '¬∞': ' deg',    # degree
            '¬±': '+/-',     # plus minus
            '√ó': 'x',       # multiplication
            '√∑': '/',       # division
            '‚âà': '~',       # approximately
            '‚â†': '!=',      # not equal
            '‚â§': '<=',      # less than or equal
            '‚â•': '>=',      # greater than or equal
            '‚àû': 'inf',     # infinity
            '\u200b': '',   # zero-width space
            '\u00a0': ' ',  # non-breaking space
            '\ufeff': '',   # BOM
        }
        
        for old, new in replacements.items():
            text = text.replace(old, new)
        
        # Remove any remaining non-latin1 characters if using Helvetica
        if self.unicode_font == 'Helvetica':
            text = text.encode('latin-1', errors='replace').decode('latin-1')
        
        return text


def parse_markdown_to_pdf(md_content: str, pdf: ResearchReportPDF):
    """Parse markdown content and add to PDF"""
    
    lines = md_content.split('\n')
    i = 0
    in_table = False
    table_headers = []
    table_rows = []
    current_list_type = None
    list_number = 0
    
    while i < len(lines):
        line = lines[i].strip()
        
        # Skip empty lines
        if not line:
            if in_table and table_headers:
                pdf.add_table(table_headers, table_rows)
                in_table = False
                table_headers = []
                table_rows = []
            current_list_type = None
            i += 1
            continue
        
        # Table handling
        if line.startswith('|') and '|' in line[1:]:
            cells = [c.strip() for c in line.split('|')[1:-1]]
            
            if not in_table:
                # Check if next line is separator
                if i + 1 < len(lines) and re.match(r'\|[-:\s|]+\|', lines[i + 1].strip()):
                    in_table = True
                    table_headers = cells
                    i += 2  # Skip header and separator
                    continue
            else:
                table_rows.append(cells)
            i += 1
            continue
        
        # Headers
        if line.startswith('# ') and not line.startswith('## '):
            # Title (H1) - usually handled separately
            title = line[2:].strip()
            if pdf.page_no() == 0:
                pdf.add_title_page(title)
            i += 1
            continue
        
        if line.startswith('## '):
            if in_table:
                pdf.add_table(table_headers, table_rows)
                in_table = False
                table_headers = []
                table_rows = []
            pdf.add_chapter_title(line[3:].strip(), level=2)
            i += 1
            continue
        
        if line.startswith('### '):
            pdf.add_chapter_title(line[4:].strip(), level=3)
            i += 1
            continue
        
        if line.startswith('#### '):
            pdf.add_chapter_title(line[5:].strip(), level=4)
            i += 1
            continue
        
        # Horizontal rule
        if line in ['---', '***', '___']:
            pdf.add_horizontal_rule()
            i += 1
            continue
        
        # Bullet points
        if line.startswith('- ') or line.startswith('* '):
            text = line[2:].strip()
            indent = 0
            # Check for nested bullets
            original_line = lines[i]
            if original_line.startswith('   '):
                indent = 1
            pdf.add_bullet_point(text, indent)
            current_list_type = 'bullet'
            i += 1
            continue
        
        # Numbered lists
        match = re.match(r'^(\d+)\.\s+(.+)$', line)
        if match:
            num = int(match.group(1))
            text = match.group(2).strip()
            pdf.add_numbered_item(num, text)
            current_list_type = 'numbered'
            list_number = num
            i += 1
            continue
        
        # Italic subtitle (after title)
        if line.startswith('*') and line.endswith('*') and 'Survey' in line:
            i += 1
            continue
        
        # Regular paragraph
        # Collect multiple lines into one paragraph
        paragraph_lines = [line]
        while i + 1 < len(lines):
            next_line = lines[i + 1].strip()
            if not next_line or next_line.startswith('#') or next_line.startswith('-') or \
               next_line.startswith('*') or next_line.startswith('|') or \
               re.match(r'^\d+\.', next_line) or next_line in ['---', '***', '___']:
                break
            paragraph_lines.append(next_line)
            i += 1
        
        paragraph = ' '.join(paragraph_lines)
        pdf.add_paragraph(paragraph)
        i += 1
    
    # Handle remaining table
    if in_table and table_headers:
        pdf.add_table(table_headers, table_rows)


def generate_pdf(markdown_path: str, output_path: str = None) -> str:
    """
    Generate PDF from markdown file.
    
    Args:
        markdown_path: Path to markdown file
        output_path: Output PDF path (default: same name with .pdf)
    
    Returns:
        str: Path to generated PDF
    """
    
    if not FPDF_AVAILABLE:
        raise ImportError("fpdf2 package not installed. Run: pip install fpdf2")
    
    # Read markdown
    print(f"Reading markdown from: {markdown_path}")
    with open(markdown_path, 'r', encoding='utf-8') as f:
        md_content = f.read()
    
    # Set output path
    if not output_path:
        output_path = os.path.splitext(markdown_path)[0] + '.pdf'
    
    # Create PDF
    print("Generating PDF...")
    pdf = ResearchReportPDF()
    
    # Extract title from first H1
    title_match = re.search(r'^#\s+(.+)$', md_content, re.MULTILINE)
    title = title_match.group(1).strip() if title_match else "Research Report"
    
    # Add title page
    pdf.add_title_page(title)
    
    # Start content on new page
    pdf.add_page()
    
    # Parse and add content
    parse_markdown_to_pdf(md_content, pdf)
    
    # Save PDF
    pdf.output(output_path)
    
    print(f"‚úÖ PDF generated: {output_path}")
    
    # Get file size
    size_kb = os.path.getsize(output_path) / 1024
    print(f"   Size: {size_kb:.1f} KB")
    
    return output_path


def main():
    parser = argparse.ArgumentParser(
        description="Generate PDF from markdown research report (simple version)"
    )
    parser.add_argument(
        "input",
        nargs="?",
        help="Input markdown file path"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output PDF path (default: same name with .pdf extension)"
    )
    
    args = parser.parse_args()
    
    if not args.input:
        parser.print_help()
        return 1
    
    if not os.path.exists(args.input):
        print(f"‚ùå File not found: {args.input}")
        return 1
    
    try:
        output_path = generate_pdf(
            markdown_path=args.input,
            output_path=args.output
        )
        print(f"\nüéâ Success! Open your PDF:\n   {output_path}")
        return 0
    except Exception as e:
        print(f"\n‚ùå Error generating PDF: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

